From 05938305f644f90b9766d5f8b42847787e7b158d Mon Sep 17 00:00:00 2001
From: Yu Chien Peter Lin <peterlin@andestech.com>
Date: Mon, 20 May 2024 16:35:13 +0800
Subject: [PATCH 16/17] core: kernel: factor out shared memory boot-time
 helpers

The static and dynamic shared memory helpers used for boot-time
reservation/registration are non-architecture-specific. Moving
them into the generic boot.c file will help avoid duplicated code
and improve maintainability.

Signed-off-by: Yu Chien Peter Lin <peterlin@andestech.com>
Reviewed-by: Alvin Chang <alvinga@andestech.com>
Reviewed-by: Jerome Forissier <jerome.forissier@linaro.org>
---
 core/arch/arm/kernel/boot.c | 197 ------------------------------------
 core/include/kernel/boot.h  |   6 ++
 core/kernel/boot.c          | 195 +++++++++++++++++++++++++++++++++++
 core/kernel/sub.mk          |   1 +
 4 files changed, 202 insertions(+), 197 deletions(-)
 create mode 100644 core/kernel/boot.c

diff --git a/core/arch/arm/kernel/boot.c b/core/arch/arm/kernel/boot.c
index 9ce891f55..640d58f5b 100644
--- a/core/arch/arm/kernel/boot.c
+++ b/core/arch/arm/kernel/boot.c
@@ -873,133 +873,6 @@ static int config_psci(struct dt_descriptor *dt __unused)
 }
 #endif /*CFG_PSCI_ARM32*/
 
-#ifdef CFG_CORE_DYN_SHM
-static uint64_t get_dt_val_and_advance(const void *data, size_t *offs,
-				       uint32_t cell_size)
-{
-	uint64_t rv = 0;
-
-	if (cell_size == 1) {
-		uint32_t v;
-
-		memcpy(&v, (const uint8_t *)data + *offs, sizeof(v));
-		*offs += sizeof(v);
-		rv = fdt32_to_cpu(v);
-	} else {
-		uint64_t v;
-
-		memcpy(&v, (const uint8_t *)data + *offs, sizeof(v));
-		*offs += sizeof(v);
-		rv = fdt64_to_cpu(v);
-	}
-
-	return rv;
-}
-
-/*
- * Find all non-secure memory from DT. Memory marked inaccessible by Secure
- * World is ignored since it could not be mapped to be used as dynamic shared
- * memory.
- */
-static int get_nsec_memory_helper(void *fdt, struct core_mmu_phys_mem *mem)
-{
-	const uint8_t *prop = NULL;
-	uint64_t a = 0;
-	uint64_t l = 0;
-	size_t prop_offs = 0;
-	size_t prop_len = 0;
-	int elems_total = 0;
-	int addr_size = 0;
-	int len_size = 0;
-	int offs = 0;
-	size_t n = 0;
-	int len = 0;
-
-	addr_size = fdt_address_cells(fdt, 0);
-	if (addr_size < 0)
-		return 0;
-
-	len_size = fdt_size_cells(fdt, 0);
-	if (len_size < 0)
-		return 0;
-
-	while (true) {
-		offs = fdt_node_offset_by_prop_value(fdt, offs, "device_type",
-						     "memory",
-						     sizeof("memory"));
-		if (offs < 0)
-			break;
-
-		if (fdt_get_status(fdt, offs) != (DT_STATUS_OK_NSEC |
-						   DT_STATUS_OK_SEC))
-			continue;
-
-		prop = fdt_getprop(fdt, offs, "reg", &len);
-		if (!prop)
-			continue;
-
-		prop_len = len;
-		for (n = 0, prop_offs = 0; prop_offs < prop_len; n++) {
-			a = get_dt_val_and_advance(prop, &prop_offs, addr_size);
-			if (prop_offs >= prop_len) {
-				n--;
-				break;
-			}
-
-			l = get_dt_val_and_advance(prop, &prop_offs, len_size);
-			if (mem) {
-				mem->type = MEM_AREA_DDR_OVERALL;
-				mem->addr = a;
-				mem->size = l;
-				mem++;
-			}
-		}
-
-		elems_total += n;
-	}
-
-	return elems_total;
-}
-
-static struct core_mmu_phys_mem *get_nsec_memory(void *fdt, size_t *nelems)
-{
-	struct core_mmu_phys_mem *mem = NULL;
-	int elems_total = 0;
-
-	elems_total = get_nsec_memory_helper(fdt, NULL);
-	if (elems_total <= 0)
-		return NULL;
-
-	mem = nex_calloc(elems_total, sizeof(*mem));
-	if (!mem)
-		panic();
-
-	elems_total = get_nsec_memory_helper(fdt, mem);
-	assert(elems_total > 0);
-
-	*nelems = elems_total;
-
-	return mem;
-}
-#endif /*CFG_CORE_DYN_SHM*/
-
-#ifdef CFG_CORE_RESERVED_SHM
-static int mark_static_shm_as_reserved(struct dt_descriptor *dt)
-{
-	vaddr_t shm_start;
-	vaddr_t shm_end;
-
-	core_mmu_get_mem_by_type(MEM_AREA_NSEC_SHM, &shm_start, &shm_end);
-	if (shm_start != shm_end)
-		return add_res_mem_dt_node(dt, "optee_shm",
-					   virt_to_phys((void *)shm_start),
-					   shm_end - shm_start);
-
-	DMSG("No SHM configured");
-	return -1;
-}
-#endif /*CFG_CORE_RESERVED_SHM*/
-
 static int mark_tzdram_as_reserved(struct dt_descriptor *dt)
 {
 	return add_res_mem_dt_node(dt, "optee_core", CFG_TZDRAM_START,
@@ -1031,14 +904,6 @@ static void update_external_dt(void)
 static void update_external_dt(void)
 {
 }
-
-#ifdef CFG_CORE_DYN_SHM
-static struct core_mmu_phys_mem *get_nsec_memory(void *fdt __unused,
-						 size_t *nelems __unused)
-{
-	return NULL;
-}
-#endif /*CFG_CORE_DYN_SHM*/
 #endif /*!CFG_DT*/
 
 #if defined(CFG_CORE_FFA)
@@ -1098,68 +963,6 @@ static void reinit_manifest_dt(void)
 }
 #endif /*CFG_CORE_FFA*/
 
-#ifdef CFG_CORE_DYN_SHM
-static void discover_nsec_memory(void)
-{
-	struct core_mmu_phys_mem *mem;
-	const struct core_mmu_phys_mem *mem_begin = NULL;
-	const struct core_mmu_phys_mem *mem_end = NULL;
-	size_t nelems;
-	void *fdt = get_external_dt();
-
-	if (fdt) {
-		mem = get_nsec_memory(fdt, &nelems);
-		if (mem) {
-			core_mmu_set_discovered_nsec_ddr(mem, nelems);
-			return;
-		}
-
-		DMSG("No non-secure memory found in external DT");
-	}
-
-	fdt = get_embedded_dt();
-	if (fdt) {
-		mem = get_nsec_memory(fdt, &nelems);
-		if (mem) {
-			core_mmu_set_discovered_nsec_ddr(mem, nelems);
-			return;
-		}
-
-		DMSG("No non-secure memory found in embedded DT");
-	}
-
-	mem_begin = phys_ddr_overall_begin;
-	mem_end = phys_ddr_overall_end;
-	nelems = mem_end - mem_begin;
-	if (nelems) {
-		/*
-		 * Platform cannot use both register_ddr() and the now
-		 * deprecated register_dynamic_shm().
-		 */
-		assert(phys_ddr_overall_compat_begin ==
-		       phys_ddr_overall_compat_end);
-	} else {
-		mem_begin = phys_ddr_overall_compat_begin;
-		mem_end = phys_ddr_overall_compat_end;
-		nelems = mem_end - mem_begin;
-		if (!nelems)
-			return;
-		DMSG("Warning register_dynamic_shm() is deprecated, please use register_ddr() instead");
-	}
-
-	mem = nex_calloc(nelems, sizeof(*mem));
-	if (!mem)
-		panic();
-
-	memcpy(mem, phys_ddr_overall_begin, sizeof(*mem) * nelems);
-	core_mmu_set_discovered_nsec_ddr(mem, nelems);
-}
-#else /*CFG_CORE_DYN_SHM*/
-static void discover_nsec_memory(void)
-{
-}
-#endif /*!CFG_CORE_DYN_SHM*/
-
 #ifdef CFG_NS_VIRTUALIZATION
 static TEE_Result virt_init_heap(void)
 {
diff --git a/core/include/kernel/boot.h b/core/include/kernel/boot.h
index 279053290..cab30aa6a 100644
--- a/core/include/kernel/boot.h
+++ b/core/include/kernel/boot.h
@@ -7,6 +7,7 @@
 #define __KERNEL_BOOT_H
 
 #include <initcall.h>
+#include <kernel/dt.h>
 #include <types_ext.h>
 
 /*
@@ -101,4 +102,9 @@ void *get_manifest_dt(void);
  */
 unsigned long get_aslr_seed(void);
 
+/* Identify non-secure memory regions for dynamic shared memory */
+void discover_nsec_memory(void);
+/* Add reserved memory for static shared memory in the device-tree */
+int mark_static_shm_as_reserved(struct dt_descriptor *dt);
+
 #endif /* __KERNEL_BOOT_H */
diff --git a/core/kernel/boot.c b/core/kernel/boot.c
new file mode 100644
index 000000000..08d36af56
--- /dev/null
+++ b/core/kernel/boot.c
@@ -0,0 +1,195 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2015-2023, Linaro Limited
+ * Copyright (c) 2023, Arm Limited
+ */
+
+#include <kernel/boot.h>
+#include <kernel/dt.h>
+#include <libfdt.h>
+#include <mm/core_memprot.h>
+
+#ifdef CFG_CORE_DYN_SHM
+static uint64_t get_dt_val_and_advance(const void *data, size_t *offs,
+				       uint32_t cell_size)
+{
+	uint64_t rv = 0;
+
+	if (cell_size == 1) {
+		uint32_t v;
+
+		memcpy(&v, (const uint8_t *)data + *offs, sizeof(v));
+		*offs += sizeof(v);
+		rv = fdt32_to_cpu(v);
+	} else {
+		uint64_t v;
+
+		memcpy(&v, (const uint8_t *)data + *offs, sizeof(v));
+		*offs += sizeof(v);
+		rv = fdt64_to_cpu(v);
+	}
+
+	return rv;
+}
+
+/*
+ * Find all non-secure memory from DT. Memory marked inaccessible by Secure
+ * World is ignored since it could not be mapped to be used as dynamic shared
+ * memory.
+ */
+static int __maybe_unused get_nsec_memory_helper(void *fdt, struct core_mmu_phys_mem *mem)
+{
+	const uint8_t *prop = NULL;
+	uint64_t a = 0;
+	uint64_t l = 0;
+	size_t prop_offs = 0;
+	size_t prop_len = 0;
+	int elems_total = 0;
+	int addr_size = 0;
+	int len_size = 0;
+	int offs = 0;
+	size_t n = 0;
+	int len = 0;
+
+	addr_size = fdt_address_cells(fdt, 0);
+	if (addr_size < 0)
+		return 0;
+
+	len_size = fdt_size_cells(fdt, 0);
+	if (len_size < 0)
+		return 0;
+
+	while (true) {
+		offs = fdt_node_offset_by_prop_value(fdt, offs, "device_type",
+						     "memory",
+						     sizeof("memory"));
+		if (offs < 0)
+			break;
+
+		if (fdt_get_status(fdt, offs) != (DT_STATUS_OK_NSEC |
+						   DT_STATUS_OK_SEC))
+			continue;
+
+		prop = fdt_getprop(fdt, offs, "reg", &len);
+		if (!prop)
+			continue;
+
+		prop_len = len;
+		for (n = 0, prop_offs = 0; prop_offs < prop_len; n++) {
+			a = get_dt_val_and_advance(prop, &prop_offs, addr_size);
+			if (prop_offs >= prop_len) {
+				n--;
+				break;
+			}
+
+			l = get_dt_val_and_advance(prop, &prop_offs, len_size);
+			if (mem) {
+				mem->type = MEM_AREA_DDR_OVERALL;
+				mem->addr = a;
+				mem->size = l;
+				mem++;
+			}
+		}
+
+		elems_total += n;
+	}
+
+	return elems_total;
+}
+
+#ifdef CFG_DT
+static struct core_mmu_phys_mem *get_nsec_memory(void *fdt, size_t *nelems)
+{
+	struct core_mmu_phys_mem *mem = NULL;
+	int elems_total = 0;
+
+	elems_total = get_nsec_memory_helper(fdt, NULL);
+	if (elems_total <= 0)
+		return NULL;
+
+	mem = nex_calloc(elems_total, sizeof(*mem));
+	if (!mem)
+		panic();
+
+	elems_total = get_nsec_memory_helper(fdt, mem);
+	assert(elems_total > 0);
+
+	*nelems = elems_total;
+
+	return mem;
+}
+#else /*CFG_DT*/
+static struct core_mmu_phys_mem *get_nsec_memory(void *fdt __unused,
+						 size_t *nelems __unused)
+{
+	return NULL;
+}
+#endif /*!CFG_DT*/
+
+void discover_nsec_memory(void)
+{
+	struct core_mmu_phys_mem *mem;
+	const struct core_mmu_phys_mem *mem_begin = NULL;
+	const struct core_mmu_phys_mem *mem_end = NULL;
+	size_t nelems;
+	void *fdt = get_external_dt();
+
+	if (fdt) {
+		mem = get_nsec_memory(fdt, &nelems);
+		if (mem) {
+			core_mmu_set_discovered_nsec_ddr(mem, nelems);
+			return;
+		}
+
+		DMSG("No non-secure memory found in FDT");
+	}
+
+	mem_begin = phys_ddr_overall_begin;
+	mem_end = phys_ddr_overall_end;
+	nelems = mem_end - mem_begin;
+	if (nelems) {
+		/*
+		 * Platform cannot use both register_ddr() and the now
+		 * deprecated register_dynamic_shm().
+		 */
+		assert(phys_ddr_overall_compat_begin ==
+		       phys_ddr_overall_compat_end);
+	} else {
+		mem_begin = phys_ddr_overall_compat_begin;
+		mem_end = phys_ddr_overall_compat_end;
+		nelems = mem_end - mem_begin;
+		if (!nelems)
+			return;
+		DMSG("Warning register_dynamic_shm() is deprecated, "
+		     "please use register_ddr() instead");
+	}
+
+	mem = nex_calloc(nelems, sizeof(*mem));
+	if (!mem)
+		panic();
+
+	memcpy(mem, phys_ddr_overall_begin, sizeof(*mem) * nelems);
+	core_mmu_set_discovered_nsec_ddr(mem, nelems);
+}
+#else /*CFG_CORE_DYN_SHM*/
+void discover_nsec_memory(void)
+{
+}
+#endif /*!CFG_CORE_DYN_SHM*/
+
+#ifdef CFG_CORE_RESERVED_SHM
+int mark_static_shm_as_reserved(struct dt_descriptor *dt)
+{
+	vaddr_t shm_start;
+	vaddr_t shm_end;
+
+	core_mmu_get_mem_by_type(MEM_AREA_NSEC_SHM, &shm_start, &shm_end);
+	if (shm_start != shm_end)
+		return add_res_mem_dt_node(dt, "optee_shm",
+					   virt_to_phys((void *)shm_start),
+					   shm_end - shm_start);
+
+	DMSG("No SHM configured");
+	return -1;
+}
+#endif /*CFG_CORE_RESERVED_SHM*/
diff --git a/core/kernel/sub.mk b/core/kernel/sub.mk
index 4d2b21e7a..e345543c1 100644
--- a/core/kernel/sub.mk
+++ b/core/kernel/sub.mk
@@ -5,6 +5,7 @@ srcs-y += assert.c
 srcs-y += console.c
 srcs-$(CFG_DT) += dt.c
 srcs-$(CFG_DT) += dt_driver.c
+srcs-y += boot.c
 srcs-y += pm.c
 srcs-y += handle.c
 srcs-y += interrupt.c
-- 
2.34.1

