From 98a43089a980f709d536fef3c7681552644aad34 Mon Sep 17 00:00:00 2001
From: Yu Chien Peter Lin <peterlin@andestech.com>
Date: Thu, 14 Mar 2024 09:56:21 +0800
Subject: [PATCH 4/8] Add SBI RPXY support for OP-TEE

---
 arch/riscv/include/asm/sbi.h |  19 +++++-
 arch/riscv/lib/sbi.c         | 129 +++++++++++++++++++++++++++++++++++
 cmd/riscv/sbi.c              |   1 +
 drivers/tee/optee/core.c     | 112 ++++++++++++++++++++++--------
 4 files changed, 231 insertions(+), 30 deletions(-)

diff --git a/arch/riscv/include/asm/sbi.h b/arch/riscv/include/asm/sbi.h
index ad32dedb58..26f7bf95e7 100644
--- a/arch/riscv/include/asm/sbi.h
+++ b/arch/riscv/include/asm/sbi.h
@@ -35,6 +35,7 @@ enum sbi_ext_id {
 	SBI_EXT_STA = 0x535441,
 	SBI_EXT_DBTR = 0x44425452,
 	SBI_EXT_SSE = 0x535345,
+	SBI_EXT_RPXY = 0x52505859,
 };
 
 enum sbi_ext_base_fid {
@@ -102,6 +103,14 @@ enum sbi_ext_dbcn_fid {
 	SBI_EXT_DBCN_CONSOLE_WRITE_BYTE,
 };
 
+enum sbi_ext_rpxy_fid {
+	SBI_EXT_RPXY_PROBE = 0,
+	SBI_EXT_RPXY_SETUP_SHMEM,
+	SBI_EXT_RPXY_SEND_NORMAL_MSG,
+	SBI_EXT_RPXY_SEND_POSTED_MSG,
+	SBI_EXT_RPXY_GET_NOTIFICATIONS,
+};
+
 #ifdef CONFIG_SBI_V01
 #define SBI_EXT_SET_TIMER		SBI_EXT_0_1_SET_TIMER
 #define SBI_FID_SET_TIMER		0
@@ -173,5 +182,13 @@ int sbi_get_marchid(long *marchid);
 int sbi_get_mimpid(long *mimpid);
 void sbi_srst_reset(unsigned long type, unsigned long reason);
 int sbi_dbcn_write_byte(unsigned char ch);
-
+int sbi_rpxy_srvgrp_probe(u32 transportid, u32 srvgrpid, unsigned long *val);
+int sbi_rpxy_setup_shmem(void);
+int sbi_rpxy_send_normal_message(u32 transportid, u32 srvgrpid, u8 srvid,
+				 void *tx, unsigned long tx_msglen,
+				 void *rx, unsigned long *rx_msglen);
+int sbi_rpxy_send_posted_message(u32 transportid, u32 srvgrpid, u8 srvid,
+				 void *tx, unsigned long tx_msglen);
+int sbi_rpxy_get_notifications(u32 transportid, u32 srvgrpid,
+			       void *rx, unsigned long *rx_msglen);
 #endif
diff --git a/arch/riscv/lib/sbi.c b/arch/riscv/lib/sbi.c
index 35a7d3b12f..fc52536929 100644
--- a/arch/riscv/lib/sbi.c
+++ b/arch/riscv/lib/sbi.c
@@ -10,6 +10,8 @@
 #include <errno.h>
 #include <asm/encoding.h>
 #include <asm/sbi.h>
+#include <linux/compat.h>
+#include <malloc.h>
 
 struct sbiret sbi_ecall(int ext, int fid, unsigned long arg0,
 			unsigned long arg1, unsigned long arg2,
@@ -220,6 +222,133 @@ int sbi_dbcn_write_byte(unsigned char ch)
 	return ret.error;
 }
 
+struct sbi_rpxy {
+	void *shmem;
+	bool active;
+};
+
+static struct sbi_rpxy sbi_rpxy_hart_data;
+
+int sbi_rpxy_setup_shmem()
+{
+        struct sbiret ret = { };
+        struct sbi_rpxy *rpxy = &sbi_rpxy_hart_data;
+        void *shmem = NULL;
+
+        if (rpxy->active) {
+                return SBI_ERR_FAILURE;
+        }
+
+        /* Allocate 4 KiB memory aligend with 4 KiB (required by SBI RPXY). */
+        shmem = memalign(PAGE_SIZE, PAGE_SIZE);
+        if (!shmem) {
+                printf("Allocate RPXY shared memory fail");
+                return -ENOMEM;
+        }
+        rpxy->shmem = shmem;
+
+        ret = sbi_ecall(SBI_EXT_RPXY, SBI_EXT_RPXY_SETUP_SHMEM,
+                        PAGE_SIZE, (unsigned long)rpxy->shmem, 0, 0, 0, 0);
+        if (ret.error) {
+                printf("Setup RPXY shared memory error %ld", ret.error);
+                return -ENOSYS;
+        }
+
+        rpxy->active = true;
+
+        printf("Setup RPXY shared memory OK, PA: 0x%p, VA: 0x%p\n",
+               rpxy->shmem, rpxy->shmem);
+
+        return ret.error;
+}
+
+int sbi_rpxy_srvgrp_probe(u32 transportid, u32 srvgrpid, unsigned long *val)
+{
+	struct sbiret ret;
+	struct sbi_rpxy *rpxy;
+
+	//if (!sbi_rpxy_available())
+	//	return -ENODEV;
+
+	rpxy = &sbi_rpxy_hart_data;
+
+	ret = sbi_ecall(SBI_EXT_RPXY, SBI_EXT_RPXY_PROBE,
+		  transportid, srvgrpid, 0, 0, 0, 0);
+	if (val)
+		*val = ret.value;
+
+	return ret.error;
+}
+
+int sbi_rpxy_send_normal_message(u32 transportid, u32 srvgrpid, u8 srvid,
+				 void *tx, unsigned long tx_msglen,
+				 void *rx, unsigned long *rx_msglen)
+{
+	struct sbiret ret;
+	struct sbi_rpxy *rpxy = &sbi_rpxy_hart_data;
+
+	//if (!sbi_rpxy_available() || !rpxy->active)
+	if (!rpxy->active)
+		return -ENODEV;
+
+	if (tx_msglen)
+		memcpy(rpxy->shmem, tx, tx_msglen);
+
+	/* Shared memory is copied with message data at 0x0 offset */
+	ret = sbi_ecall(SBI_EXT_RPXY, SBI_EXT_RPXY_SEND_NORMAL_MSG,
+			 transportid, srvgrpid, srvid, tx_msglen, 0, 0);
+
+	if (!ret.error && rx) {
+		memcpy(rx, rpxy->shmem, ret.value);
+		if (rx_msglen)
+			*rx_msglen = ret.value;
+	}
+
+	return ret.error;
+}
+
+int sbi_rpxy_send_posted_message(u32 transportid, u32 srvgrpid, u8 srvid,
+				 void *tx, unsigned long tx_msglen)
+{
+	struct sbiret ret;
+	struct sbi_rpxy *rpxy = &sbi_rpxy_hart_data;
+
+	//if (!sbi_rpxy_available() || !rpxy->active)
+	if (!rpxy->active)
+		return -ENODEV;
+
+	if (tx_msglen)
+		memcpy(rpxy->shmem, tx, tx_msglen);
+
+	/* Shared memory is copied with message data at 0x0 offset */
+	ret = sbi_ecall(SBI_EXT_RPXY, SBI_EXT_RPXY_SEND_POSTED_MSG,
+			 transportid, srvgrpid, srvid, tx_msglen, 0, 0);
+
+	return ret.error;
+}
+
+int sbi_rpxy_get_notifications(u32 transportid, u32 srvgrpid,
+			       void *rx, unsigned long *rx_msglen)
+{
+	struct sbiret ret;
+	struct sbi_rpxy *rpxy = &sbi_rpxy_hart_data;
+
+	//if (!sbi_rpxy_available() || !rpxy->active)
+	if (!rpxy->active)
+		return -ENODEV;
+
+	ret = sbi_ecall(SBI_EXT_RPXY, SBI_EXT_RPXY_GET_NOTIFICATIONS,
+			transportid, srvgrpid, 0, 0, 0, 0);
+
+	if (!ret.error && rx) {
+		memcpy(rx, rpxy->shmem, ret.value);
+		if (rx_msglen)
+			*rx_msglen = ret.value;
+	}
+
+	return ret.error;
+}
+
 #ifdef CONFIG_SBI_V01
 
 /**
diff --git a/cmd/riscv/sbi.c b/cmd/riscv/sbi.c
index 2d8ee7e5bb..c07d121d6b 100644
--- a/cmd/riscv/sbi.c
+++ b/cmd/riscv/sbi.c
@@ -57,6 +57,7 @@ static struct sbi_ext extensions[] = {
 	{ SBI_EXT_STA,			      "Steal-time Accounting Extension" },
 	{ SBI_EXT_DBTR,			      "Debug Trigger Extension" },
 	{ SBI_EXT_SSE,			      "Supervisor Software Events" },
+	{ SBI_EXT_RPXY,			      "SBI RPMI Proxy (RPXY) Extension" },
 };
 
 static int do_sbi(struct cmd_tbl *cmdtp, int flag, int argc,
diff --git a/drivers/tee/optee/core.c b/drivers/tee/optee/core.c
index 42e38a73cb..2dfea1219d 100644
--- a/drivers/tee/optee/core.c
+++ b/drivers/tee/optee/core.c
@@ -14,11 +14,59 @@
 #include <linux/err.h>
 #include <linux/io.h>
 #include <tee/optee_service.h>
+#include <asm/sbi.h>
 
 #include "optee_smc.h"
 #include "optee_msg.h"
 #include "optee_private.h"
 
+/** RPXY transport protocol type */
+#define RPXY_TRANS_PROT_MASK	(0xFFFF0000)
+#define RPXY_TRANS_PROT_SHIFT	(16)
+enum rpxy_transport_protocol {
+	RPXY_TRANS_PROT_RPMI = 0,
+	RPXY_TRANS_PROT_SEC = 1,
+	RPXY_TRANS_PROT_ID_MAX_COUNT,
+};
+
+/** SPD TEE ServiceGroups IDs */
+enum spd_servicegroup_id {
+	SPD_SRVGRP_ID_MIN = 0,
+	SPD_SRVGRP_BASE = 0x00001,
+	SPD_SRVGRP_ID_MAX_COUNT,
+};
+
+/** SPD TEE Base ServiceGroup Service IDs */
+enum spd_base_service_id {
+	SPD_BASE_SRV_COMMUNICATE = 0x01,
+	SPD_BASE_SRV_COMPLETE = 0x02,
+};
+
+struct sbi_rpxy_ctx {
+	u32 tpid;
+	u32 max_msg_len;
+};
+
+struct rpmi_tee_tx {
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long a4;
+	unsigned long a5;
+	unsigned long a6;
+	unsigned long a7;
+};
+
+struct rpmi_tee_rx {
+	unsigned long value;
+	unsigned long extp1;
+	unsigned long extp2;
+	unsigned long extp3;
+};
+
+static struct sbi_rpxy_ctx rpxy_ctx;
+
 #define PAGELIST_ENTRIES_PER_PAGE \
 	((OPTEE_MSG_NONCONTIG_PAGE_SIZE / sizeof(u64)) - 1)
 
@@ -763,41 +811,49 @@ static void optee_smccc_smc(unsigned long a0, unsigned long a1,
 			    unsigned long a6, unsigned long a7,
 			    struct arm_smccc_res *res)
 {
-	//arm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res);
-}
+#ifndef CONFIG_RISCV
+	arm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res);
+#else
+	struct rpmi_tee_tx tx;
+	struct rpmi_tee_rx rx;
+	unsigned long rxmsg_len;
+	int ret;
 
-static void optee_smccc_hvc(unsigned long a0, unsigned long a1,
-			    unsigned long a2, unsigned long a3,
-			    unsigned long a4, unsigned long a5,
-			    unsigned long a6, unsigned long a7,
-			    struct arm_smccc_res *res)
-{
-	//arm_smccc_hvc(a0, a1, a2, a3, a4, a5, a6, a7, res);
+	sbi_rpxy_setup_shmem();
+
+	tx.a0 = a0;
+	tx.a1 = a1;
+	tx.a2 = a2;
+	tx.a3 = a3;
+	tx.a4 = a4;
+	tx.a5 = a5;
+	tx.a6 = a6;
+	tx.a7 = a7;
+	ret = sbi_rpxy_send_normal_message(rpxy_ctx.tpid |
+				((RPXY_TRANS_PROT_SEC << RPXY_TRANS_PROT_SHIFT)
+				& RPXY_TRANS_PROT_MASK),
+				SPD_SRVGRP_BASE,
+				SPD_BASE_SRV_COMMUNICATE,
+				&tx, sizeof(struct rpmi_tee_tx), &rx, &rxmsg_len);
+	if (ret)
+		pr_warn("optee_smccc_smc - riscv archtecture call result %d\n", ret);
+
+	res->a0 = rx.value;
+	res->a1 = rx.extp1;
+	res->a2 = rx.extp2;
+	res->a3 = rx.extp3;
+#endif
 }
 
-static void optee_riscv_sbi(unsigned long a0, unsigned long a1,
+static void optee_smccc_hvc(unsigned long a0, unsigned long a1,
 			    unsigned long a2, unsigned long a3,
 			    unsigned long a4, unsigned long a5,
 			    unsigned long a6, unsigned long a7,
 			    struct arm_smccc_res *res)
 {
-	/* SBI_EXT_TEE */
-	register uintptr_t __a0 asm ("a0") = a0;
-	register uintptr_t __a1 asm ("a1") = a1;
-	register uintptr_t __a2 asm ("a2") = a2;
-	register uintptr_t __a3 asm ("a3") = a3;
-	register uintptr_t __a4 asm ("a4") = a4;
-	register uintptr_t __a5 asm ("a5") = a5;
-	register uintptr_t __a6 asm ("a6") = a6;
-	register uintptr_t __a7 asm ("a7") = 0x544545;
-	asm volatile ("ecall"
-		      : "+r" (__a0), "+r" (__a1), "+r" (__a2), "+r" (__a3)
-		      : "r" (__a4), "r" (__a5), "r" (__a6), "r" (__a7)
-		      : "memory");
-	res->a0 = __a0;
-	res->a1 = __a1;
-	res->a2 = __a2;
-	res->a3 = __a3;
+#ifndef CONFIG_RISCV
+	arm_smccc_hvc(a0, a1, a2, a3, a4, a5, a6, a7, res);
+#endif
 }
 
 static optee_invoke_fn *get_invoke_func(struct udevice *dev)
@@ -815,8 +871,6 @@ static optee_invoke_fn *get_invoke_func(struct udevice *dev)
 		return optee_smccc_hvc;
 	else if (!strcmp("smc", method))
 		return optee_smccc_smc;
-	else if (!strcmp("riscv_sbi", method))
-		return optee_riscv_sbi;
 
 	debug("optee: invalid \"method\" property: %s\n", method);
 	return ERR_PTR(-EINVAL);
-- 
2.34.1

