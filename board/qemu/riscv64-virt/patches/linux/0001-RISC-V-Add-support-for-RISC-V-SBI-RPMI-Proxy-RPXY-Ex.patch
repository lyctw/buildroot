From ea3daccd2522dd1e6435e2c5294c16765914a1fc Mon Sep 17 00:00:00 2001
From: Rahul Pathak <rpathak@ventanamicro.com>
Date: Thu, 7 Sep 2023 06:36:53 +0530
Subject: [PATCH 1/3] RISC-V: Add support for RISC-V SBI RPMI Proxy(RPXY)
 Extension

SBI RPXY Extension extends RPMI protocol to S-Mode.
S-Mode clients can send/receive rpmi messages using
this sbi extension interface

Signed-off-by: Rahul Pathak <rpathak@ventanamicro.com>
---
 arch/riscv/include/asm/sbi.h |  21 ++++
 arch/riscv/kernel/Makefile   |   1 +
 arch/riscv/kernel/rpxy-sbi.c | 202 +++++++++++++++++++++++++++++++++++
 3 files changed, 224 insertions(+)
 create mode 100644 arch/riscv/kernel/rpxy-sbi.c

diff --git a/arch/riscv/include/asm/sbi.h b/arch/riscv/include/asm/sbi.h
index 6e68f8dff76b..54cbaaba9495 100644
--- a/arch/riscv/include/asm/sbi.h
+++ b/arch/riscv/include/asm/sbi.h
@@ -33,6 +33,7 @@ enum sbi_ext_id {
 	SBI_EXT_PMU = 0x504D55,
 	SBI_EXT_DBCN = 0x4442434E,
 	SBI_EXT_STA = 0x535441,
+	SBI_EXT_RPXY = 0x52505859,
 
 	/* Experimentals extensions must lie within this range */
 	SBI_EXT_EXPERIMENTAL_START = 0x08000000,
@@ -88,6 +89,14 @@ enum sbi_hsm_hart_state {
 	SBI_HSM_STATE_RESUME_PENDING,
 };
 
+enum sbi_ext_rpxy_fid {
+	SBI_EXT_RPXY_PROBE = 0,
+	SBI_EXT_RPXY_SETUP_SHMEM,
+	SBI_EXT_RPXY_SEND_NORMAL_MSG,
+	SBI_EXT_RPXY_SEND_POSTED_MSG,
+	SBI_EXT_RPXY_GET_NOTIFICATIONS,
+};
+
 #define SBI_HSM_SUSP_BASE_MASK			0x7fffffff
 #define SBI_HSM_SUSP_NON_RET_BIT		0x80000000
 #define SBI_HSM_SUSP_PLAT_BASE			0x10000000
@@ -380,4 +389,16 @@ void sbi_ipi_init(void);
 static inline void sbi_ipi_init(void) { }
 #endif
 
+int sbi_rpxy_srvgrp_probe(u32 transportid, u32 srvgrpid, unsigned long *val);
+
+int sbi_rpxy_send_normal_message(u32 transportid, u32 srvgrpid, u8 srvid,
+				 void *tx, unsigned long tx_msglen,
+				 void *rx, unsigned long *rx_msglen);
+
+int sbi_rpxy_send_posted_message(u32 transportid, u32 srvgrpid, u8 srvid,
+				 void *tx, unsigned long tx_msglen);
+
+int sbi_rpxy_get_notifications(u32 transportid, u32 srvgrpid,
+			       void *rx, unsigned long *rx_msglen);
+
 #endif /* _ASM_RISCV_SBI_H */
diff --git a/arch/riscv/kernel/Makefile b/arch/riscv/kernel/Makefile
index 81d94a8ee10f..aa5ac13d3971 100644
--- a/arch/riscv/kernel/Makefile
+++ b/arch/riscv/kernel/Makefile
@@ -109,3 +109,4 @@ obj-$(CONFIG_COMPAT)		+= compat_vdso/
 
 obj-$(CONFIG_64BIT)		+= pi/
 obj-$(CONFIG_ACPI)		+= acpi.o
+obj-y				+= rpxy-sbi.o
diff --git a/arch/riscv/kernel/rpxy-sbi.c b/arch/riscv/kernel/rpxy-sbi.c
new file mode 100644
index 000000000000..998bf8c8b040
--- /dev/null
+++ b/arch/riscv/kernel/rpxy-sbi.c
@@ -0,0 +1,202 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * RISC-V RPMI Proxy (RPXY) Helper functions
+ *
+ * Copyright (C) 2023 Ventana Micro Systems Inc.
+ */
+
+#define pr_fmt(fmt) "riscv-rpxy: " fmt
+
+#include <asm/sbi.h>
+#include <linux/percpu.h>
+#include <linux/mm.h>
+#include <linux/cpu.h>
+#include <linux/smp.h>
+
+struct sbi_rpxy {
+	void *shmem;
+	phys_addr_t shmem_phys;
+	bool active;
+};
+
+DEFINE_PER_CPU(struct sbi_rpxy, sbi_rpxy);
+
+DEFINE_STATIC_KEY_FALSE(sbi_rpxy_available);
+#define sbi_rpxy_available() \
+	static_branch_unlikely(&sbi_rpxy_available)
+
+int sbi_rpxy_srvgrp_probe(u32 transportid, u32 srvgrpid, unsigned long *val)
+{
+	struct sbiret sret;
+	struct sbi_rpxy *rpxy;
+
+	if (!sbi_rpxy_available())
+		return -ENODEV;
+
+	rpxy = this_cpu_ptr(&sbi_rpxy);
+
+	get_cpu();
+	sret = sbi_ecall(SBI_EXT_RPXY, SBI_EXT_RPXY_PROBE,
+		  transportid, srvgrpid, 0, 0, 0, 0);
+	if (val)
+		*val = sret.value;
+	put_cpu();
+
+	return sbi_err_map_linux_errno(sret.error);
+}
+EXPORT_SYMBOL(sbi_rpxy_srvgrp_probe);
+
+int sbi_rpxy_send_normal_message(u32 transportid, u32 srvgrpid, u8 srvid,
+				 void *tx, unsigned long tx_msglen,
+				 void *rx, unsigned long *rx_msglen)
+{
+	struct sbiret sret;
+	struct sbi_rpxy *rpxy = this_cpu_ptr(&sbi_rpxy);
+
+	if (!sbi_rpxy_available() || !rpxy->active)
+		return -ENODEV;
+
+	get_cpu();
+	if (tx_msglen)
+		memcpy(rpxy->shmem, tx, tx_msglen);
+
+	/* Shared memory is copied with message data at 0x0 offset */
+	sret = sbi_ecall(SBI_EXT_RPXY, SBI_EXT_RPXY_SEND_NORMAL_MSG,
+			 transportid, srvgrpid, srvid, tx_msglen, 0, 0);
+
+	if (!sret.error && rx) {
+		memcpy(rx, rpxy->shmem, sret.value);
+		if (rx_msglen)
+			*rx_msglen = sret.value;
+	}
+	put_cpu();
+
+	return sbi_err_map_linux_errno(sret.error);
+}
+EXPORT_SYMBOL(sbi_rpxy_send_normal_message);
+
+int sbi_rpxy_send_posted_message(u32 transportid, u32 srvgrpid, u8 srvid,
+				 void *tx, unsigned long tx_msglen)
+{
+	struct sbiret sret;
+	struct sbi_rpxy *rpxy = this_cpu_ptr(&sbi_rpxy);
+
+	if (!sbi_rpxy_available() || !rpxy->active)
+		return -ENODEV;
+
+	get_cpu();
+	if (tx_msglen)
+		memcpy(rpxy->shmem, tx, tx_msglen);
+
+	/* Shared memory is copied with message data at 0x0 offset */
+	sret = sbi_ecall(SBI_EXT_RPXY, SBI_EXT_RPXY_SEND_POSTED_MSG,
+			 transportid, srvgrpid, srvid, tx_msglen, 0, 0);
+	put_cpu();
+
+	return sbi_err_map_linux_errno(sret.error);
+}
+EXPORT_SYMBOL(sbi_rpxy_send_posted_message);
+
+int sbi_rpxy_get_notifications(u32 transportid, u32 srvgrpid,
+			       void *rx, unsigned long *rx_msglen)
+{
+	struct sbiret sret;
+	struct sbi_rpxy *rpxy = this_cpu_ptr(&sbi_rpxy);
+
+	if (!sbi_rpxy_available() || !rpxy->active)
+		return -ENODEV;
+
+	get_cpu();
+	sret = sbi_ecall(SBI_EXT_RPXY, SBI_EXT_RPXY_GET_NOTIFICATIONS,
+			transportid, srvgrpid, 0, 0, 0, 0);
+
+	if (!sret.error && rx) {
+		memcpy(rx, rpxy->shmem, sret.value);
+		if (rx_msglen)
+			*rx_msglen = sret.value;
+	}
+	put_cpu();
+
+	return sbi_err_map_linux_errno(sret.error);
+}
+EXPORT_SYMBOL(sbi_rpxy_get_notifications);
+
+static int sbi_rpxy_exit(unsigned int cpu)
+{
+	struct sbi_rpxy *rpxy;
+
+	if (!sbi_rpxy_available())
+		return -ENODEV;
+
+	rpxy = per_cpu_ptr(&sbi_rpxy, cpu);
+
+	if (!rpxy->shmem)
+		return -ENOMEM;
+
+	free_pages((unsigned long)rpxy->shmem, get_order(PAGE_SIZE));
+	rpxy->shmem = NULL;
+	rpxy->shmem_phys = 0;
+	rpxy->active = false;
+
+	return 0;
+}
+
+static int sbi_rpxy_setup_shmem(unsigned int cpu)
+{
+	struct sbiret sret;
+	struct page *shmem_page;
+	struct sbi_rpxy *rpxy;
+
+	if (!sbi_rpxy_available())
+		return -ENODEV;
+
+	rpxy = per_cpu_ptr(&sbi_rpxy, cpu);
+	if (rpxy->active)
+		return -EINVAL;
+
+	shmem_page = alloc_pages(GFP_KERNEL | __GFP_ZERO,
+				 get_order(PAGE_SIZE));
+	if (!shmem_page) {
+		sbi_rpxy_exit(cpu);
+		pr_err("Shared memory setup failed for cpu-%d\n", cpu);
+		return -ENOMEM;
+	}
+
+	rpxy->shmem = page_to_virt(shmem_page);
+	rpxy->shmem_phys = page_to_phys(shmem_page);
+
+	sret = sbi_ecall(SBI_EXT_RPXY, SBI_EXT_RPXY_SETUP_SHMEM,
+			PAGE_SIZE, rpxy->shmem_phys, 0, 0, 0, 0);
+	if (sret.error) {
+		sbi_rpxy_exit(cpu);
+		return sbi_err_map_linux_errno(sret.error);
+	}
+
+	rpxy->active = true;
+
+	return 0;
+}
+
+static int __init sbi_rpxy_init(void)
+{
+	if ((sbi_spec_version < sbi_mk_version(1, 0)) ||
+		sbi_probe_extension(SBI_EXT_RPXY) <= 0) {
+		return -ENODEV;
+	}
+
+	static_branch_enable(&sbi_rpxy_available);
+	pr_info("SBI RPXY extension detected\n");
+
+	/*
+	 * Setup CPUHP notifier to setup shared
+	 * memory on all CPUs
+	 */
+	cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,
+			  "riscv/rpxy-sbi:cpu-shmem-init",
+			  sbi_rpxy_setup_shmem,
+			  sbi_rpxy_exit);
+
+	return 0;
+}
+
+arch_initcall(sbi_rpxy_init);
-- 
2.34.1

