From 9c1d8eb76290620d4744ae8c161a56cd3a74f274 Mon Sep 17 00:00:00 2001
From: Yong Li <yong.li@intel.com>
Date: Tue, 20 Feb 2024 09:16:58 +0800
Subject: [PATCH 2/3] Add RPXY driver for TEE

This is a base RPXY driver to support dispatch
TEE OSs. Initially, the open source OPTEE is tested.

Signed-off-by: Yong Li <yong.li@intel.com>
Co-developed-by: Alvin Chang <alvinga@andestech.com>
Signed-off-by: Alvin Chang <alvinga@andestech.com>
---
 arch/riscv/configs/defconfig |  12 ++++
 drivers/tee/Kconfig          |   2 +-
 drivers/tee/optee/Kconfig    |   2 +-
 drivers/tee/optee/call.c     |   2 +
 drivers/tee/optee/smc_abi.c  | 111 +++++++++++++++++++++++++++++++++++
 5 files changed, 127 insertions(+), 2 deletions(-)

diff --git a/arch/riscv/configs/defconfig b/arch/riscv/configs/defconfig
index fc0ec2ee13bc..e78aaa0d84dc 100644
--- a/arch/riscv/configs/defconfig
+++ b/arch/riscv/configs/defconfig
@@ -299,3 +299,15 @@ CONFIG_RCU_EQS_DEBUG=y
 # CONFIG_FTRACE is not set
 # CONFIG_RUNTIME_TESTING_MENU is not set
 CONFIG_MEMTEST=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+CONFIG_9P_FS=y
+CONFIG_9P_FS_POSIX_ACL=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_EFI_GENERIC_STUB_INITRD_CMDLINE_LOADER=y
+CONFIG_DEBUG_INFO_DWARF5=y
+CONFIG_READABLE_ASM=y
+CONFIG_GDB_SCRIPTS=y
diff --git a/drivers/tee/Kconfig b/drivers/tee/Kconfig
index 73a147202e88..2e6d776ddab4 100644
--- a/drivers/tee/Kconfig
+++ b/drivers/tee/Kconfig
@@ -2,7 +2,7 @@
 # Generic Trusted Execution Environment Configuration
 menuconfig TEE
 	tristate "Trusted Execution Environment support"
-	depends on HAVE_ARM_SMCCC || COMPILE_TEST || CPU_SUP_AMD
+	depends on HAVE_ARM_SMCCC || COMPILE_TEST || CPU_SUP_AMD || RISCV_SBI
 	select CRYPTO
 	select CRYPTO_SHA1
 	select DMA_SHARED_BUFFER
diff --git a/drivers/tee/optee/Kconfig b/drivers/tee/optee/Kconfig
index 976928641aa6..16241d9a1da3 100644
--- a/drivers/tee/optee/Kconfig
+++ b/drivers/tee/optee/Kconfig
@@ -2,7 +2,7 @@
 # OP-TEE Trusted Execution Environment Configuration
 config OPTEE
 	tristate "OP-TEE"
-	depends on HAVE_ARM_SMCCC
+	depends on HAVE_ARM_SMCCC || RISCV_SBI
 	depends on MMU
 	help
 	  This implements the OP-TEE Trusted Execution Environment (TEE)
diff --git a/drivers/tee/optee/call.c b/drivers/tee/optee/call.c
index a91e50be11be..2ca9eb46a800 100644
--- a/drivers/tee/optee/call.c
+++ b/drivers/tee/optee/call.c
@@ -603,6 +603,8 @@ static bool is_normal_memory(pgprot_t p)
 		((pgprot_val(p) & L_PTE_MT_MASK) == L_PTE_MT_WRITEBACK));
 #elif defined(CONFIG_ARM64)
 	return (pgprot_val(p) & PTE_ATTRINDX_MASK) == PTE_ATTRINDX(MT_NORMAL);
+#elif defined(CONFIG_RISCV)
+	return true;
 #else
 #error "Unsupported architecture"
 #endif
diff --git a/drivers/tee/optee/smc_abi.c b/drivers/tee/optee/smc_abi.c
index a37f87087e5c..f7314a7fcffe 100644
--- a/drivers/tee/optee/smc_abi.c
+++ b/drivers/tee/optee/smc_abi.c
@@ -32,6 +32,7 @@
 #include <linux/kmemleak.h>
 #define CREATE_TRACE_POINTS
 #include "optee_trace.h"
+#include <asm/sbi.h>
 
 /*
  * This file implement the SMC ABI used when communicating with secure world
@@ -1388,6 +1389,53 @@ optee_config_shm_memremap(optee_invoke_fn *invoke_fn, void **memremaped_shm)
 	return rc;
 }
 
+/** RPXY transport protocol type */
+#define RPXY_TRANS_PROT_MASK	(0xFFFF0000)
+#define RPXY_TRANS_PROT_SHIFT	(16)
+enum rpxy_transport_protocol {
+	RPXY_TRANS_PROT_RPMI = 0,
+	RPXY_TRANS_PROT_SEC = 1,
+	RPXY_TRANS_PROT_ID_MAX_COUNT,
+};
+
+/** SPD TEE ServiceGroups IDs */
+enum spd_servicegroup_id {
+	SPD_SRVGRP_ID_MIN = 0,
+	SPD_SRVGRP_BASE = 0x00001,
+	SPD_SRVGRP_ID_MAX_COUNT,
+};
+
+/** SPD TEE Base ServiceGroup Service IDs */
+enum spd_base_service_id {
+	SPD_BASE_SRV_COMMUNICATE = 0x01,
+	SPD_BASE_SRV_COMPLETE = 0x02,
+};
+
+struct sbi_rpxy_ctx {
+	u32 tpid;
+	u32 max_msg_len;
+};
+
+struct rpmi_tee_tx {
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long a4;
+	unsigned long a5;
+	unsigned long a6;
+	unsigned long a7;
+};
+
+struct rpmi_tee_rx {
+	unsigned long value;
+	unsigned long extp1;
+	unsigned long extp2;
+	unsigned long extp3;
+};
+
+static struct sbi_rpxy_ctx rpxy_ctx;
+
 /* Simple wrapper functions to be able to use a function pointer */
 static void optee_smccc_smc(unsigned long a0, unsigned long a1,
 			    unsigned long a2, unsigned long a3,
@@ -1395,7 +1443,36 @@ static void optee_smccc_smc(unsigned long a0, unsigned long a1,
 			    unsigned long a6, unsigned long a7,
 			    struct arm_smccc_res *res)
 {
+#ifndef CONFIG_RISCV
 	arm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res);
+#else
+	struct rpmi_tee_tx tx;
+	struct rpmi_tee_rx rx;
+	unsigned long rxmsg_len;
+	int ret;
+
+	tx.a0 = a0;
+	tx.a1 = a1;
+	tx.a2 = a2;
+	tx.a3 = a3;
+	tx.a4 = a4;
+	tx.a5 = a5;
+	tx.a6 = a6;
+	tx.a7 = a7;
+	ret = sbi_rpxy_send_normal_message(rpxy_ctx.tpid |
+				((RPXY_TRANS_PROT_SEC << RPXY_TRANS_PROT_SHIFT)
+				& RPXY_TRANS_PROT_MASK),
+				SPD_SRVGRP_BASE,
+				SPD_BASE_SRV_COMMUNICATE,
+				&tx, sizeof(struct rpmi_tee_tx), &rx, &rxmsg_len);
+	if (ret)
+		pr_warn("optee_smccc_smc - riscv archtecture call result %d\n", ret);
+
+	res->a0 = rx.value;
+	res->a1 = rx.extp1;
+	res->a2 = rx.extp2;
+	res->a3 = rx.extp3;
+#endif
 }
 
 static void optee_smccc_hvc(unsigned long a0, unsigned long a1,
@@ -1404,7 +1481,9 @@ static void optee_smccc_hvc(unsigned long a0, unsigned long a1,
 			    unsigned long a6, unsigned long a7,
 			    struct arm_smccc_res *res)
 {
+#ifndef CONFIG_RISCV
 	arm_smccc_hvc(a0, a1, a2, a3, a4, a5, a6, a7, res);
+#endif
 }
 
 static optee_invoke_fn *get_invoke_func(struct device *dev)
@@ -1585,6 +1664,34 @@ static inline int optee_load_fw(struct platform_device *pdev,
 }
 #endif
 
+static int sbi_rpxy_tee_probe(struct platform_device *pdev)
+{
+	u32 tpid;
+	long max_msg_len;
+	int ret, num_clocks, clkid;
+	struct clk_hw *hw_ptr;
+	struct clk_hw_onecell_data *clk_data;
+
+	if ((sbi_spec_version < sbi_mk_version(1, 0)) ||
+		sbi_probe_extension(SBI_EXT_RPXY) <= 0) {
+		dev_err(&pdev->dev, "sbi rpxy extension not present\n");
+		return -ENODEV;
+	}
+
+	rpxy_ctx.tpid = 0x0;
+	ret = sbi_rpxy_srvgrp_probe(rpxy_ctx.tpid |
+				((RPXY_TRANS_PROT_SEC << RPXY_TRANS_PROT_SHIFT)
+				& RPXY_TRANS_PROT_MASK),
+				SPD_SRVGRP_BASE, &max_msg_len);
+	if (!max_msg_len) {
+		dev_err(&pdev->dev, "RPXY SPD TEE Service Group Probe Failed\n");
+		return -ENODEV;
+	}
+	rpxy_ctx.max_msg_len = max_msg_len;
+
+	return ret;
+}
+
 static int optee_probe(struct platform_device *pdev)
 {
 	optee_invoke_fn *invoke_fn;
@@ -1600,6 +1707,10 @@ static int optee_probe(struct platform_device *pdev)
 	u32 sec_caps;
 	int rc;
 
+	rc = sbi_rpxy_tee_probe(pdev);
+	if (rc)
+		return rc;
+
 	invoke_fn = get_invoke_func(&pdev->dev);
 	if (IS_ERR(invoke_fn))
 		return PTR_ERR(invoke_fn);
-- 
2.34.1

